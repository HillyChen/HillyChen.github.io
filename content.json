{"meta":{"title":"草泥上的蚂蚁","subtitle":"知无不言  言无不尽","description":null,"author":"sunniberg","url":"http://hillychen.github.io"},"pages":[{"title":"resource","date":"2017-03-12T12:01:15.000Z","updated":"2017-03-18T14:04:36.000Z","comments":true,"path":"resource/index.html","permalink":"http://hillychen.github.io/resource/index.html","excerpt":"","text":"电子书资源 技术不断发展，知识不断更新，唯有不断的学习才能活得充实，各行各业都是如此；我认为比较好的电子书，基本是技术书和少许的其他领域的书。在这里分享给大家，但是要支持正版，可以购买电子版的正版； 链接：坚果云 算法学习网站 leecode geeksforgeeks 开发文档 PHP文档中文 PHP文档英文 Python文档 电子书目录可以使用Ctrl + F来检索。 沉浸式学习git 高效程序员的45个习惯：敏捷开发修炼之道 恰如其分的软件架构 设计模式之禅(第二版) 深入理解Java虚拟机 图解http 微服务设计 有生之年必看的101部电影 三体三部曲 algorithm android编程权威指南 css设计指南(第三版) Dive into Python function-swift-cn Html5秘籍 HTTP权威指南 ios编程(第四版) jQuery基础教程（第4版）-图灵程序设计丛书 leetcode题解 MySQL性能调优与架构设计 Netty in Action 算法大杂烩 php和mysql web开发(原书第4版) (开发人员专业技术丛书) Programming with Objective-C - v1.0 Ruby-on-Rails-Jiao-Cheng-Michael-Hartl Sprite Kit编程指南 Swift基础教程 (图灵程序设计丛书) - [美]皮特（Boisy G. Pitre） Vim实用技巧"},{"title":"about","date":"2017-03-12T06:57:46.000Z","updated":"2017-03-12T06:58:44.000Z","comments":true,"path":"about/index.html","permalink":"http://hillychen.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2017-03-12T10:12:18.000Z","updated":"2017-03-12T10:12:18.000Z","comments":true,"path":"resume/index.html","permalink":"http://hillychen.github.io/resume/index.html","excerpt":"","text":"陈旭山 body { background: #EEEEEE; font: 12px \"Times New Roman\", Times, sans-serif; line-height: 1.4; margin: 40px 0; } em { color: #999; } p { line-height: 1.4; } ul { margin-bottom: 0; } li { margin-bottom: 2px; } a { text-decoration: none; } #resume { margin: 0 auto; max-width: 600px; padding: 90px 100px 70px 100px; background: #fff; border: 1px solid #ccc; box-shadow: 2px 2px 4px #aaa; -webkit-box-shadow: 2px 2px 4px #aaa; } .coursesList { width: 28%; vertical-align: top; display: inline-block; } .largeFont { font-size: 20px; } .smallFont { font-size: 12px; } .sectionName { width: 18%; vertical-align: top; display: inline-block; } .sectionContent { width: 80%; vertical-align: top; display: inline-block } .sectionContent ul { padding-left: 20px; margin-top: 6px; list-style-type: circle; } .sectionContent .title { font-weight: bold; } .sectionContent .date { float: right; } .sectionContent .separator { height: 14px; } .sectionLine { border-style: dashed; border-width: 1px; border-color: #CFCFCF; margin-top: 13px; margin-bottom: 13px; } .divider { font-weight: bold; margin-left: 5px; margin-right: 5px; } .summary { margin-top: 6px; } .skillBlock { margin-bottom: 4px; } .head{ float:right; height:93px; width:82px; /*border-radius: 1;*/ margin-top: -92px; -moz-border-radius: 41px / 45px; -webkit-border-radius: 41px / 45px; border-radius: 41px / 45px; } .title1{ font-weight: bold; font-size: 13px; } /* Media Queries */ @media only screen and (max-width: 40em) { body { margin: 0; font-size: 14px; } #resume { margin: 0 auto; max-width: 600px; padding: 0.5em 1em; border: none; } .sectionContent { width: 100%; } .sectionContent .date { padding-right: 2em; } .sectionName { width: auto; } .largeFont { font-size: 20px; } .smallFont { font-size: 14px; } } @media print { #resume { margin: 0 auto; max-width: 600px; padding: 0px 0px; border: 0px; background: #fff; box-shadow: none; -webkit-box-shadow: none; } } 陈旭山 Email:344926445@qq.com | Phone:18896555121 | Address:江苏省苏州市 Blog :http://hillychen.github.io 简介 苏州大学 计算机软件工程专业 经历 苏州大学 2012-2016 获奖情况 大学获奖 学习优秀二等奖学金 2014-11-01 学习优秀二等奖学金 2015-11-01 苏州大学计算机学院科协优秀理事 2014-10-09 职位与锻炼 大学期间担任过班级副班长 计算机学院科技协会科研部部长 计算机学院科技协会理事长 大二大三在导师实验室进行专业学习锻炼 技能 Web Development: HTML, CSS, Javascript Program Language: C, C++, SQL, PHP, Python, Database: Mysql, SqlServer Operation Systems: windows, Mac OS, Linux(Ubuntu) Development Framework: Git/Svn, Laravel, Django, Jquery/D3.js/toDoT.js UI design: Sketch 项目经验 苏大计算机学院导师制平台微信公众号开发(Python) 益智积分管理系统(PHP)(http://www.yqbte.cn/) 基于APICloud跨平台校园信息平台APP开发(Html/Javascript/Css) 语言 English: CET4 CET6 实习工作经历 苏州畅达软件公司实习工作 2015-07--2015-11 中国银行苏州分行信息科技部 2016-07--2016-08 兴趣爱好 生活 [ 阅读，听音乐，看电影 ] 专业 [ 学习IT行业比较好的技术，开发工具 生命有限，学习无限，知识是无限的，但是最重要的就是保持着一颗对知识渴求的心态，学习方法 最重要 ] 座右铭 [ 不仅仅只有眼前的苟且，还有诗与远方 这世界没有末路，你也不曾孤独 ]"},{"title":"movie&music","date":"2017-03-12T14:33:23.000Z","updated":"2017-06-05T13:57:01.000Z","comments":true,"path":"movie-music/index.html","permalink":"http://hillychen.github.io/movie-music/index.html","excerpt":"","text":"爱好 鄙人喜欢听音乐看电影，所以平时作为兴趣维护着一个电影音乐的公众号，喜欢电影音乐的朋友欢迎关注，知无不尽，言无不尽；公众号：music_movie_love百度云盘地址: https://pan.baidu.com/s/1ceWRc6 密码: 7fr8 文章标题 阅读 关乎现代人类文明史上黑暗事件 点击阅读 人鬼情未了 点击阅读 童年经典《西游记》音影俱佳 点击阅读 速8也好，激8也罢，都牛叉！ 点击阅读 飓风营救三部曲 点击阅读 我所向往的生活 点击阅读 God Father 点击阅读 一首《弹棉花》勾起一部电影的回忆 点击阅读 经典永恒 点击阅读 关乎信仰 点击阅读 《极限特工3》实力派加偶像派齐飞！ 点击阅读 蝙蝠侠： 致命玩笑 点击阅读 两位先生 点击阅读 平凡人的传奇故事 点击阅读 影史上神奇的1994年，经典无数，百花齐放！ 点击阅读 西班牙恐怖片《吾栖之肤》！ 点击阅读 致敬经典的演唱会live(beyond&amp;&amp;The Beatles) 点击阅读 佳片推荐：《机械姬》（2015） 点击阅读 比较虐心的9部电影 点击阅读 《老九门》人物关系介绍 点击阅读 启示录 点击阅读 好莱坞大片特效前后对比，考验演员演技！ 点击阅读 两个版本的《演员》，您喜欢哪个版本？ 点击阅读 佳片推荐: 七磅 （Seven Pounds） 点击阅读 电影常识系列(一) 点击阅读 人类的第一次自拍照片原来是这样！ 点击阅读 史上最具颠覆力的电视剧 点击阅读 法兰西玫瑰–苏菲玛索 点击阅读 南京人配音国外影视作品，连科比都爆笑！ 点击阅读 史上最强悍点球大战！ 点击阅读 Transformers:《变形金刚》——钢铁摇滚的饕餮盛宴 点击阅读 周杰伦和他背后的男人们！ 点击阅读 春风十里 点击阅读 中国明星试镜《权利的游戏》！小恶魔亮了！ 点击阅读 从暴雪资料片CG了解你所不知道的魔兽世界（一）——经典旧世 点击阅读 李小龙好莱坞试镜时的珍贵视频，不愧是一代宗师 点击阅读 《余罪》里面最搞笑的一段视频 点击阅读 You are not alone 点击阅读 我干脆自己下车，指挥乐坛的交通 点击阅读 美的不是下雨天，而是与你躲过雨的屋檐 点击阅读 祝天下的父亲们节日快乐！ 点击阅读 新娘都是天使，因为天使爱美丽 点击阅读 我唾弃你的坟墓 点击阅读 跨越古典与现代流行的钢琴王子 点击阅读 Pride and Prejudice–Smile 点击阅读"}],"posts":[{"title":"计算机网络","slug":"计算机网络","date":"2017-09-24T13:28:54.000Z","updated":"2017-09-24T13:45:51.000Z","comments":true,"path":"2017/09/24/计算机网络/","link":"","permalink":"http://hillychen.github.io/2017/09/24/计算机网络/","excerpt":"","text":"从事IT行业的人，可能有一部分人不是科班出身，或者即使是科班出身，可能对计算机的一些基础理论知识掌握的不是很牢靠，目前国内的计算机学院的专业课程中最重要的就是这四门：计算机组成、操作系统、数据结构、计算机网络。这四门也是目前计算机考研所涉及的，很重要，也很基础，虽然现在很多软件开发人员在工作中都不涉及这些知识，但是对于大公司来说，要想深入技术领域产品的研发，这些知识是很重要的，所以对于打算一直走技术路线的人来说，职业生涯很有必要抽出时间进行学习。八个字：“巩固、充实、深入、探索”。下面是整理的一些思维导图。 计算机网络体系 物理层 数据链路层","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://hillychen.github.io/categories/计算机基础/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://hillychen.github.io/tags/计算机基础/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://hillychen.github.io/categories/计算机基础/"}]},{"title":"sketch学习笔记以及设计相关知识积累","slug":"sketch学习笔记以及设计相关知识积累","date":"2017-05-29T14:35:17.000Z","updated":"2017-06-10T14:58:42.000Z","comments":true,"path":"2017/05/29/sketch学习笔记以及设计相关知识积累/","link":"","permalink":"http://hillychen.github.io/2017/05/29/sketch学习笔记以及设计相关知识积累/","excerpt":"","text":"sketch是设计师眼中一款很牛逼的设计软件，和PS的一个区别就是sketch是矢量图的设计软件sketch学习网站 sketch.im skecth中国社区 to add …. sketch插件 安装的三种方法： sketch toolbox github下载插件项目，直接双击压缩包里面的.sketchplugin的插件文件 直接将解压缩包里面的插件文件拷贝放到Plugins路径下插件： Duplicator:快捷键复制插件 Content Generator:自动内容填充 Magic mirror:选中一个区域，可以将你制定的一个图片去填充选中区域，比如图片中一个手机界面，可以用钢笔描边选中，然后用另一张图片去填充图片中手机的屏幕，具体用法是把屏幕用vector工具转变成path sketch Style Inventory:导入所有的设计稿的颜色、文本样式、元件 Material Design Color Palette Sketch Plugin:生成配色方案的插件 sketch notebook:标注设计稿的注意事项 Sketch Measure: 标注尺寸 神奇的点9图 只针对android手机开发者设计图片时制作，例如微信聊天文字对话框会根据文字的多少，手机屏幕尺寸进行拉伸，所以点9图产生了。PS也可以制作点9图具体参考如下教程制作工具/插件 UI实战UI界面设计工作流程 根据原型或者交互稿设计UI界面 在手机上预览设计稿 设计稿的沟通修改和确认环节 根据设计稿输出高保真的demo(可选) 设计稿的标注 切图 开发完成后的视觉走查","categories":[{"name":"sketch design","slug":"sketch-design","permalink":"http://hillychen.github.io/categories/sketch-design/"}],"tags":[{"name":"sketch design","slug":"sketch-design","permalink":"http://hillychen.github.io/tags/sketch-design/"}],"keywords":[{"name":"sketch design","slug":"sketch-design","permalink":"http://hillychen.github.io/categories/sketch-design/"}]},{"title":"css学习笔记","slug":"css学习笔记","date":"2017-04-22T06:53:00.000Z","updated":"2017-07-16T09:28:51.000Z","comments":true,"path":"2017/04/22/css学习笔记/","link":"","permalink":"http://hillychen.github.io/2017/04/22/css学习笔记/","excerpt":"","text":"最近需要为自己的公众号开发一个小程序，所以要温习一下css样式知识，在此做个笔记也供以后便捷温习学习； css学习笔记 样式 行内样式：This paragraph simply takes on the browser’s default paragraph style.By adding inline CSS styling to this paragraph, you override the default styles. 嵌入式样式： h1 {font-size:16px;} p {color:blue;} 链接样式：@import url(css/styles2.css) 选择符： 上下文选择符 特殊的上下文选择符：子选择符、紧邻同胞选择符+、一般同胞选择符~、通用选择符*、 ID选择符：href=”#id”定位到顶部或id那个地方 类选择符：多类 属性选择符:img[title] {border:2px solid blue;} 属性值选择符：img[title=”red flower”] {border:4px solid green;} 伪类UI（User Interface，用户界面）伪类会在HTML元素处于某个状态时（比如鼠标指针位于链接上），为该元素应用CSS样式。 链接伪类 Link。此时，链接就在那儿等着用户点击。 Visited。用户此前点击过这个链接。 Hover。鼠标指针正悬停在链接上。 Active。链接正在被点击（鼠标在元素上按下，还没有释放）。p:hover {background-color:gray;} :focus伪类:e:focus{}e代表任何元素input:focus {border:1px solid blue;} :target伪类“More InformationThis is the information you are looking for.”#more_info:target {background:#eee;}” 结构化伪类会在标记中存在某种结构上的关系时（如某个元素是一组元素中的第一个或最后一个），为相应元素应用CSS样式。 :first-child和:last-child 123456ol.results li:first-child &#123;color:blue;&#125;||ol.results li:last-child &#123;color:red;&#125;&lt;ol class=\"results\"&gt; &lt;li&gt;My Fast Pony&lt;/li&gt; &lt;li&gt;Steady Trotter&lt;/li&gt; &lt;li&gt;Slow Ol' Nag&lt;/li&gt;&lt;/ol&gt; :nth-childe:nth-child(n)/e:nth-child(odd)/e:nth-child(even) 伪元素 ::first-letter伪元素:p::first-letter {font-size:300%;}(段落首字符放大的效果，也可以用一个实现) ::first-line伪元素：p::first-line {font-variant:small-caps;}p::first-line {font-variant:small-caps;} (第一行以小型大写字母显示) ::before和::after伪元素 1234&lt;p class=\"age\"&gt;25&lt;/p&gt;p.age::before &#123;content:\"Age: \";&#125;p.age::after &#123;content:\" years.\";&#125;Age: 25 years. 这种用法可以用在后台查询数据给前台时，进行一些渲染 继承-层叠-特指在一个较大的样式表中，可能会有很多条规则都选择同一个元素的同一个属性。比如，一个带有类属性的段落，可能会被一条以标签名作选择符的规则选中并指定一种字体，而另一条以该段落的类名作选择符的规则却会给它指定另一种字体。我们知道，字体属性在任意时刻都只能应用一种设定，那此时该应用哪种字体呢？为解决类似的冲突，确定哪条规则“胜出”并最终被应用，CSS提供了三种机制：继承、层叠和特指。接下来的三节，就分别讨论这三种机制。 继承body {font-family:helvetica, arial, sans-serif;}body是所有所有元素的祖宗，所有元素都会继承它的样式，对于个别想使用自己的样式，只需自身指定即可，就如同OOP编程语言里面的类继承类似，如果子类想定义自己从父类的方法，也可重写实现自己的特性。有些属性可以继承：颜色、字体、字号等有些属性不能继承：边框、外边距、内边距 层叠样式来源以下就是浏览器层叠各个来源样式的顺序： 浏览器默认样式表 用户样式表 作者链接样式表（按照它们链接到页面的先后顺序） 作者嵌入样式 作者行内样式以上样式会以冒泡交换的法则进行继承式替换。层叠规则 层叠规则一：找到应用给每个元素和属性的所有声明。浏览器在加载每个页面时，都会据此查到每一条CSS规则，标识出所有受到影响的HTML元素 层叠规则二：按照顺序和权重排序。浏览器依次检查5个来源，并设定匹配的属性。如果匹配的属性在下一个来源也有定义，则更新该属性的值，如此循环，直到检查完页面中所有标签受影响属性的全部5个来源为止。最终某个属性被设定成什么值，就用什么值来显示。声明也可以有权重。可以像下面这样为单独的声明增加权重：p {color:green !important; font-size:12pt;}空格!important分号（;）用于加重声明的权重。这条规则加重了将文本设置为绿色的权重。于是，就算层叠的下一来源给段落设定了其他颜色，最终的颜色值仍然还是绿色。 层叠规则三：按特指度排序，举例来说就是比如类选择符选中的规则比普通标签选择要高。这里涉及到特指度的计算：I - C - E 选择符中有一个ID，就在I的位置上加1； 选择符中有一个类，就在C的位置上加1； 选择符中有一个元素（标签）名，就在E的位置上加1； 得到一个三位数。 层叠规则四：顺序决定权重。如果两条规则都影响某元素的同一个属性，而且它们的特指度也相同，则位置最靠下（或后声明）的规则胜出 规则声明css属性值主要分为三类 文本值：font-weight:bold 数字值(又分为相对值和绝对值)：font-size:12px 颜色值：color:#336699 十六进制颜色（#RRGGBB或#RGB):#rrggbb-十六进制以16为基数，使用数字0-9和字母a-f，共16个值。其中，a-f代表10到15。由于每种颜色用两位十六进制值表示，因此该颜色就有256（16×16）种可能的值，结果就是16 777 216（256×256×256）种组合，也就是可以表示那么多种颜色。纯红色是#ff0000，纯绿色是#00ff00，而纯蓝色是#0000ff。大多数十六进制颜色值不仔细分析可不容易猜，比如#7ca9be是深蓝绿色，我怎么知道的？ 首先我们来看每一对rgb值中的第一个值，也就是7、a、b。蓝色和绿色值相差无几，而红色值也没有那么深。有了这些信息，就可以大致猜出这个颜色了，对，是蓝绿色 RGB颜色值（R, G , B） RGB百分比值（R%, G%, B%） HSL (色相, 饱和度%, 亮度%) Alpha通道：RGBA,HSLA色彩网站 定位元素 页面版式主要由三个属性控制：position属性、display属性和float属性。其中，position属性控制页面上元素间的位置关系，display属性控制元素是堆叠、并排，还是根本不在页面上出现，float属性提供控制的方式，以便把元素组成成多栏布局。 理解盒模型 边框（border）。可以设置边框的宽窄、样式和颜色。 内边距（padding）。可以设置盒子内容区与边框的间距。 外边距（margin）。可以设置盒子与相邻元素的间距。 简写样式12345678910&#123;margin-top:5px; margin-right:10px; margin-bottom:12px; margin-left:8px;&#125;&#123;margin:5px 10px 12px 8px;&#125;&#123;margin:12px 10px 6px;&#125;/*由于没有写最后一个值（左边的值），所以左边就会使用右边的值，即10px。*/&#123;border:2px dashed red;&#125;/*全部3个属性，全部4条边 */&#123;border-style:dashed;&#125;/*1个属性，全部4条边 */&#123;border-left-style:dashed;&#125;/*1个属性，1条边*/&#123;border:4px solid red;&#125; /* 先给4条边设置相同的样式 */ &#123;border-left-width:1px;&#125; /* 修改左边框宽度 */ &#123;border-right:none;&#125; /* 移除右边框 *//*类似地，其他属性也都有这三级粒度，例如padding和border-radius等。*/ 盒子边框 边框（border）有3个相关属性。 宽度（border-width）。可以使用thin、medium和thick等文本值，也可以使用除百分比和负值之外的任何绝对值。 样式（border-style）。有none、hidden、dotted、dashed、solid、double、groove、ridge、inset和outset等文本值。 颜色（border-color）。可以使用任意颜色值，包括RGB、HSL、十六进制颜色值和颜色关键字。一般在开发中，我们会采用中和内外边距的写法，给需要边距的再单独编写样式:“* {margin:0; padding:0;}”下面的这个样式表不仅重置了外边距和内边距，还对很多元素在跨浏览器显示时的外观进行了标准化。至于为什么，可以参考博客文章1212345678910111213141516171819202122232425262728293031323334353637383940/* http://meyerweb.com/eric/tools/css/reset/ v2.0 | 20110126 License: none (public domain)*/html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup,menu, nav, output, ruby, section, summary,time, mark, audio, video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline;&#125;/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure,footer, header, hgroup, menu, nav, section &#123; display: block;&#125;body &#123; line-height: 1;&#125;ol, ul &#123; list-style: none;&#125;blockquote, q &#123; quotes: none;&#125;blockquote:before, blockquote:after,q:before, q:after &#123; content: ''; content: none;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125; 叠加外边距 请看例子1234为简明起见，省略了字体声明p &#123;height:50px; border:1px solid #000; backgroundcolor:#fff; margin-top:50px; margin-bottom:30px;&#125;由于第一段的下外边距与第二段的上外边距相邻，你自然会认为它们之间的外边距是80像素（50+30），但是你错啦！它们实际的间距是50像素。也就是说较宽的外边距决定两个元素最终离多远。 外边距的单位 根据经验，为文本元素设置外边距时通常需要混合使用不同的单位。比如说，一个段落的左、右外边距可以使用像素，以便该段文本始终与包含元素边界保持固定间距，不受字号变大或变小的影响。而对于上、下外边距，以em为单位则可以让段间距随字号变化而相应增大或缩小12/*这里使用了简写属性把上、下外边距设置为.75em，把左、右外边距设置为30像素*/p &#123;font-size:1em; margin:.75em 30px;&#125; 盒子模型详解没有宽度的盒子 12body &#123;font-family:helvetica, arial, sans-serif; font-size:1em; margin:0px; background-color:#caebff;&#125;p &#123;margin:0 30px; background-color:#fff; padding:0 20px; border:solid red; border-width:0 6px 0 6px;&#125; 外边距在元素盒子与窗口之间创造了空白，此时内容宽度变成了288像素（400 – ( (20 + 6 + 30)× 2) ）。而元素声明的总宽度并没有变，仍然是400像素。盒模型结论一：没有（就是没有设置width的）宽度的元素始终会扩展到填满其父元素的宽度为止。添加水平边框、内边距和外边距，会导致内容宽度减少，减少量等于水平边框、内边距和外边距的和。盒模型结论二：为设定了宽度的盒子添加边框、内边距和外边距，会导致盒子扩展得更宽。实际上，盒子的width属性设定的只是盒子内容区的宽度，而非盒子要占据的水平宽度。 浮动和清除 浮动和清除是用来组织页面布局的又一柄利剑，这柄剑的剑刃就是float和clear属性。浮动，你看这俩字儿多形象，意思就是把元素从常规文档流中拿出来。拿出来干什么？一是可以实现传统出版物上那种文字绕排图片的效果，二是可以让原来上下堆叠的块级元素，变成左右并列，从而实现布局中的分栏。浮动元素脱离了常规文档流之后，原来紧跟其后的元素就会在空间允许的情况下，向上提升到与浮动元素平起平坐。如果浮动元素后面有两个段落，而你只想让第一段与浮动元素并列（就算旁边还能放下第二段，也不想让它上来），怎么办？用clear属性来“清除”第二段，然后它就乖乖地呆在浮动元素下面了。 浮动CSS设计float属性的主要目的，是为了实现文本绕排图片的效果。然而，这个属性居然也成了创建多栏布局最简单的方式。文本绕排图片 …the paragraph text…/为简明起见，省略了字体声明/p {margin:0; border:1px solid red;}/外边距防止图片紧挨文本/img {float:left; margin:0 4px 4px 0;动图片会从文档流中被移除，如果在标记中有文本元素跟在它后面，则其中的文本会绕开图片.浮动非图片元素时，必须给它设定宽度，否则后果难以预料。图片无所谓，因为它本身有默认的宽度。浮动还用另一种用途是实现分栏 围住浮动元素的三种方法 为父元素添加overflow：hidden 同时浮动父元素，同时给父元素下面的文档流一个{clear:left} 添加非浮动的清除元素123456789101112131415161718192021222324&lt;section&gt; &lt;img src=\"images/rubber_duck.jpg\"&gt; &lt;p&gt;It's fun to float.&lt;/p&gt; &lt;div class=\"clear_me\"&gt;&lt;/div&gt;&lt;/section&gt;&lt;footer&gt; Here is the footer element…&lt;/footer&gt;&lt;!-- section &#123;border:1px solid blue;&#125;img &#123;float:left;&#125;.clear_me &#123;clear:left;&#125;footer &#123;border:1px solid red;&#125; --&gt;&lt;section class=\"clearfix\"&gt;&lt;img src=\"images/rubber_duck.jpg\"&gt; &lt;p&gt;It's fun to float.&lt;/p&gt;&lt;/section&gt;&lt;footer&gt; Here is the footer element…&lt;/footer&gt;&lt;!-- .clearfix:after &#123; content:\".\"; display:block; height:0; visibility:hidden; clear:both;&#125; --&gt;&lt;!-- 这个clearfix规则最早是由程序员Tony Aslett发明的，它只添加了一个清除的包含句点作为非浮动元素（必须得有内容，而句点是最小的内容）1。规则中的其他声明是为了确保这个伪元素没有高度，而且在页面上不可见。使用clear:both意味着section中新增的子元素会清除左、右浮动元素（位于左、右浮动元素下方）。这里当然可以只用left，但both也适用于将来图片float:right的情况。--&gt; 定位 CSS布局的核心是position属性，对元素盒子应用这个属性，可以相对于它在常规文档流中的位置重新定位。position属性有4个值：static、relative、absolute、fixed，默认值为static。 静态定位：static块级元素会在默认文档流中上下堆叠 相对定位reletive：相对的是它原来在文档流中的位置，可以使用top、right、bottom和left属性来改变它的位置了。但多数情况下，只用top和left就可以实现我们想要的效果。{position:relative; top:25px; left:30px;} 绝对定位absolute：绝对定位会把元素彻底从文档流中拿出来，有的时候是相对body进行定位，这就涉及到定位上下文的概念了。绝对定位默认的上下文是body元素。 固定定位fixed：从完全移出文档流的角度说，固定定位与绝对定位类似，{position:fixed; top:30px; left:20px;}，但不同之处在于，固定定位元素的定位上下文是视口（浏览器窗口或手持设备的屏幕），因此它不会随页面滚动而移动。固定定位并不常用，最常见的情况是用它创建不随页面滚动而移动的导航元素。 定位上下文:把元素的position属性设定为relative、absolute或fixed后，继而可以使用top、right、bottom和left属性，相对于另一个元素移动该元素的位置。这里的“另一个元素”，就是该元素的定位上下文。在讲绝对定位的时候，我们知道绝对定位元素默认的定位上下文是body。这是因为body是标记中所有元素唯一的祖先元素。而实际上，绝对定位元素的任何祖先元素都可以成为它的定位上下文，只要你把相应祖先元素的position设定为relative即可。 显示属性 所有元素都有postion和display,display的默认值是block和inline。块级元素和行内元素可以相互转换/默认为block/p {display:inline;}/默认为inline/a {display:block;}display属性设置为none，会把元素的display设定为none，该元素及所有包含在其中的元素，都不会在页面中显示。它们原先占据的所有空间也都会被“回收”。与此相对的是visibility属性，这个属性最常用的两个相对的值是visible（默认值）和hidden。把元素的visibility设定为hidden，元素会隐藏，但它占据的页面空间仍然“虚位以待”。 背景色 每个元素盒子都可以想象成由两个图层组成。元素的前景层包含内容（如文本或图片）和边框，元素的背景层可以用实色填充（使用background-color属性），也可以包含任意多个背景图片（使用background-image属性），背景图片叠加在背景颜色之上。 背景颜色元素的background-color是蓝绿色，段落的background-color是白色，前景色color是灰色，前景色既影响文本，也影响边框 背景图片background-image:url(images/blue_circle.png);比元素小的背景图片会在水平和垂直方向上重复出现，直至填满整个背景空间要改变默认的水平和垂直重复效果，可以修改background-repeat属性；要改变背景图片的起点，可以修改background-position属性。默认值就是repeat另外3个值分别是只在水平方向重复的repeat-x、只在垂直方向上重复的repeat-y和在任何方向上都不重复（或者说只让背景图片显示一次）的no-repeat 背景位置用于控制背景位置的background-position属性，是所有背景属性中最复杂的。background-position属性有5个关键字值，分别是top、left、bottom、right和center，这些关键字中的任意两个组合起来都可以作为该属性的值。比如，top right表示把图片放在元素的右上角位置，center center把图片放在元素的中心位置。设定背景位置时可以使用三种值：关键字、百分比、绝对或相对单位的数值 背景尺寸background-size： 50%：缩放图片，使其填充背景区的一半。 100px 50px：把图片调整到100像素宽，50像素高。 cover：拉大图片，使其完全填满背景区；保持宽高比。 contain：缩放图片，使其恰好适合背景区；保持宽高比。背景粘附“background-attachment属性控制滚动元素内的背景图片是否随元素滚动而移动。这个属性的默认值是scroll，即背景图片随元素移动。如果把它的值改为fixed，那么背景图片不会随元素滚动而移动。background-attachment:fixed最常用于给body元素中心位置添加淡色水印，让水印不随页面滚动而移动。123456789p&#123; background-image:url(images/watermark.png); background-position:center; background-color:#fff; background-repeat:no-repeat; background-size:contain; background-attachment:fixed;&#125;/*简写*/body &#123;background:url(images/watermark.png) center #fff no-repeat contain fixed;&#125; 多背景图片123456789101112131415p &#123; height:150px; width:348px; border:2px solid #aaa; margin:20px auto; font:24px/150px helvetica, arial, sansserif; text-align:center; background: url(images/turq_spiral.png) 30px -10px no-repeat, url(images/pink_spiral.png) 145px 0px no-repeat, url(images/gray_spiral.png) 140px -30px no-repeat, #ffbd75;&#125;/*多张图片可以在背景中叠加起来，CSS规则中先列出的图片在上层*/ 背景渐变 渐变分两种，一种线性渐变，一种放射性渐变。线性渐变从元素的一端延伸到另一端，放射性渐变则从元素内一点向四周发散。1234567891011121314151617181920/*为元素盒子添加样式*/div &#123; height:150px; width:200px; border:1px solid #ccc; float:left; margin:16px;&#125;/*例1：默认为从上到下*/.gradient1 &#123; background:linear-gradient(#e86a43, #fff);&#125;/*例2：从左到右*/.gradient2 &#123; background:linear-gradient(left, #64d1dd, #fff);&#125;/*例3：左上到右下*/.gradient3 &#123; background:linear-gradient(-45deg, #e86a43, #fff);&#125; 渐变点12345678910111213141516“/*例1：50%处有一个渐变点*/.gradient1 &#123; background:linear-gradient(#64d1dd, #fff 50%, #64d1dd);&#125;/*例2：20%和80%处有两个渐变点*/.gradient2 &#123; background:linear-gradient(#e86a43 20%, #fff 50%, #e86a43 80%);&#125;/*例3：25%、50%、75%处有三个渐变点*/.gradient3 &#123; background:linear-gradient(#64d1dd, #fff 25%, #64d1dd 50%, #fff 75%, #64d1dd);&#125;/*例4：为同一个渐变点设定两种颜色可以得到突变效果*/.gradient4 &#123; background:linear-gradient(#e86a43, #fff 25%, #64d1dd 25%, #64d1dd 75%, #fff 75%, #e86a43);&#125; 放射性渐变123456789.gradient1 &#123; background: -webkit-radial-gradient(#fff, #64d1dd, #70aa25);&#125;.gradient2 &#123; background: -webkit-radial-gradient(circle, #fff, #64d1dd, #e86a43);&#125;.gradient3 &#123; background: -webkit-radial-gradient(50px 30px, circle, #fff, #64d1dd, #4947ba);&#125; 厂商前缀 为鼓励浏览器厂商尽早采用W3C的CSS3推荐标准，于是就产生了VSP（Vendor Specific Prefixes，厂商前缀）的概念。有了这些CSS属性的前缀，厂商就可以尝试实现W3C涵盖新CSS属性的工作草案。在迅速实现新属性的同时，还可以声明它们是过渡的、部分实现的，或者实验性的。总之，后果由使用者自负。就拿W3C推荐的transform属性为例，标准语法是这样的：transform: skewX(-45deg);12345-moz-transform:skewX(-45deg); /* Firefox */-webkit-transform:skewX(-45deg); /* Chrome及Safari */-ms-transform:skewX(-45deg); /* 微软Internet Explorer */-o-transform:skewX(-45deg); /* Opera */transform:skewX(-45deg); /* 最后是W3C标准属性 */ Safari和Chrome都使用相同的-webkit-前缀，是因为它们都使用Webkit渲染引擎。”以下CSS3属性必须加VPS：border-image translatelinear-gradient transitionradial-gradient backgroundtransform background-imagetransform-origin 字体和文本页面布局 为了达到三栏布局，可以使用float:left,但还有时候随着给一栏增加内外边距等，会使得第三栏放不下，浮到下面，这里面有，这种情况下有三种手段解决： 从设定的元素宽度中减去添加的水平外边距、边框和内边距的宽度和。 在容器内部的元素上添加内边距或外边距。 使用CSS3的box-sizing属性切换盒子缩放方式，比如section {box-sizing:border-box;}。 应用box-sizing属性后，给section添加边框和内边距都不会增大盒子，相反会导致内容变窄。 子-星选择符预防过大的元素设计一个将来可能由他人维护的动态网站时，需要考虑得更长远一些。比如，应该预见到可能出现一些过大的元素。 img {max-width:100%;} overflow:hidden word-wrap:break-word三栏-中栏流动布局实现中栏流动布局有两种方法。一种是在中栏改变大小时使用负外边距定位右栏，另一种是使用CSS3让栏容器具有类似表格单元的行为。负外边距适合比较老的浏览器，而CSS的table属性则要简单得多 用负外边距实现：实现三栏布局且让中栏内容区流动（不固定）的核心问题，就是处理右栏的定位，并在中栏内容区大小改变时控制右栏与布局的关系。解决方案是控制两个外包装（通过ID值为wrapper）容器的外边距。其中一个外包装包围所有三栏，另一个外包装只包围左栏和中栏。123456789101112131415161718192021222324&lt;div id=\"main_wrapper\"&gt; &lt;header&gt; &lt;!-- 页眉--&gt; &lt;/header&gt; &lt;div id=\"threecolwrap\"&gt;/*三栏外包装（包围全部三栏）*/ &lt;div id=\"twocolwrap\"&gt;/*两栏外包装（包围左栏和中栏）*/ /*左栏*/ &lt;nav&gt; &lt;!-- 导航 --&gt; &lt;/nav&gt; /*中栏*/ &lt;article&gt; “ &lt;!-- 区块 --&gt; &lt;/article&gt; &lt;/div&gt;/*结束两栏外包装（twocolwrap）*/ /*右栏*/ &lt;aside&gt; &lt;!-- 侧栏 --&gt; &lt;/aside&gt; &lt;/div&gt;/*结束三栏外包装（threecolwrap）*/ &lt;footer&gt; &lt;!-- 页脚 --&gt; &lt;/footer&gt; &lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859* &#123;margin:0; padding:0;&#125;body &#123;font:1em helvetica, arial, sans-serif;&#125;div#main_wrapper&#123; min-width:600px; max-width:1100px; /*超过最大宽度时，居中布局*/ margin:0 auto; /*背景图片默认从左上角开始拼接*/ background:url(images/bg_tile_150pxw.png) repeat-y #eee; &#125; header &#123; padding:5px 10px; background:#3f7ccf; &#125; div#threecolwrap &#123; /*浮动强制它包围浮动的栏*/ float:left; width:100%; /*背景图片右对齐*/ background:url(images/bg_tile_210pxw.png) top right repeat-y; &#125; div#twocolwrap &#123; /*浮动强制它包围浮动的栏*/ float:left; width:100%; /*把右栏拉到区块外边距腾出的位置上*/ margin-right:-210px; &#125;nav &#123; float:left; width:150px; background:#f00; padding:20px 0;&#125;/*让子元素与栏边界保持一定距离*/nav &gt; * &#123;margin:0 10px;&#125;article &#123; width:auto; margin-left:150px; /*在流动居中的栏右侧腾出空间*/ margin-right:210px; background:#eee; padding:20px 0;&#125;*让子元素与栏边界保持一定距离*/article &gt; * &#123;margin:0 20px;&#125;aside &#123; float:left; width:210px; background:#ffed53; padding:20px 0;&#125; *让子元素与栏边界保持一定距离*/ aside &gt; * &#123;margin:0 10px;&#125; footer &#123; clear:both; width:100%; text-align:center; background:#000; &#125; 用CSS3单元格实现 CSS可以把一个HTML元素的display属性设定为table、table-row和table-cell。通过这种方法可以模拟相应HTML元素的行为。而通过CSS把布局中的栏设定为table-cell有三个好处。 单元格（table-cell）不需要浮动就可以并排显示，而且直接为它们应用内边距也不会破坏布局。 默认情况下，一行中的所有单元格高度相同，因而也不需要人造的等高栏效果了。 任何没有明确设定宽度的栏都是流动的。123456nav &#123;display:table-cell; width:150px; padding:10px; background:#dcd9c0;&#125;article &#123;display:table-cell; padding:10px 20px; background:#ffed53;&#125;aside &#123;display:table-cell; width:210px; padding:10px; background:#3f7ccf;&#125; 多行多栏布局 类是用来标记具有相同特征的元素的。ID最好是用来标记每个主要区域的顶级元素，这样可以充当路标。123456789101112131415161718192021222324252627282930&lt;div id=\"wrapper\"&gt; &lt;header&gt; &lt;h1&gt;Full-width content&lt;/h1&gt; &lt;/header&gt; &lt;nav&gt; &lt;p&gt;Navigation menus go here&lt;/p&gt; &lt;/nav&gt; &lt;section id=\"branding\"&gt; &lt;img src=\"images/grand_canyon.jpg\" alt=\"Grand Canyon\" /&gt; &lt;/section&gt;&lt;!-- branding 结束 --&gt; &lt;section id=\"feature_area\"&gt; &lt;article&gt; &lt;div class=\"inner\"&gt; &lt;p&gt;Lorem Ipsum text&lt;/p&gt; &lt;/div&gt; &lt;/article&gt; &lt;!-- 省略另外两个 article 元素 --&gt; &lt;/section&gt;&lt;!-- feature_area 结束--&gt; &lt;section id=\"promo_area\"&gt; &lt;article&gt; &lt;div class=\"inner\"&gt; &lt;p&gt;Lorem Ipsum text&lt;/p&gt; &lt;/div&gt; &lt;/article&gt; &lt;!-- 省略另外三个 article 元素 --&gt; &lt;/section&gt;&lt;!-- promo_area 结束--&gt; &lt;footer&gt; &lt;p&gt;A CSS template from &lt;a href=\"http://www.stylinwithcss.com\"&gt;&lt;em&gt;Stylin’ with CSS, Third Edition&lt;/em&gt;&lt;/a&gt; by Charles Wyke-Smith&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526/*每个article作为一个浮动栏*/section#feature_area article &#123; float:left; “width:320px; /*对于作为栏的容器，只能添加垂直内边距*/ padding:10px 0; background:#fff; border-top:4px solid #f7be84;&#125;/*为所有内容盒子添加公共样式*/section#feature_area article .inner &#123; margin:10px 20px; padding:5px; background:#fff; border:5px solid;&#125;/*以下三条分别为三个内容盒子设定样式*/section#feature_area article:nth-child(1) .inner &#123; border-color:#d7dd6f;&#125;section#feature_area article:nth-child(2) .inner &#123; border-color:#f6dec5;&#125;section#feature_area article:nth-child(3) .inner &#123; border-color:#d1d8e4;&#125; 界面组件纵向导航菜单12345678&lt;nav class=\"list1\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Alternative&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Country&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Jazz&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Rock&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 1234567891011121314151617/*去掉默认的内边距和外边距*/* &#123;margin:0; padding:0;&#125;/*设定本例中菜单的大小和位置*/nav &#123;margin:50px; width:150px;&#125;/*给菜单加上边框*/.list1 ul &#123;border:1px solid #f00; border-radius:3px; padding:5px 10px 3px;&#125;/*去掉项目符号并为链接添加间距*/.list1 li &#123;list-style-type:none; padding:3px 10px;&#125;/*“非首位子元素”选择符*/.list1 li + li &#123;border-top:1px solid #f00;&#125;/*为链接添加样式*/.list1 a &#123;text-decoration:none; font:20px Exo, helvetica, arial, sans-serif; font-weight:400; color:#000; background:#ffed53;&#125;/*悬停高亮*/.list1 a:hover &#123;color:#069;&#125; 使用“非首位子元素”选择符:li + li选择符的意思是“任何跟在li之后的li”。也可以这样写：/给所有li上方添加一条边框/li {border-top:1px solid #f00;}/去掉第一个li上方的边框/li:first-child {border-top:none;}改进版12345678910* &#123;margin:0; padding:0;&#125;nav &#123;margin:50px; width:150px;&#125;.list1 ul &#123;border:1px solid #f00; border-radius:3px;padding:5px 10px 3px;&#125;.list1 li &#123;list-style-type:none; padding:3px 10px;&#125;.list1 li + li a &#123;border-top:1px solid #f00;&#125;.list1 a &#123;display:block; padding:3px 10px; textdecoration: none; font:20px Exo, helvetica, arial, sansserif;font-weight:400; color:#000; background:#ffed53;&#125;.list1 a:hover &#123;color:#069;&#125; 横向菜单123456789&lt;nav class=\"list1\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Shirts&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Pants&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Dresses&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Shoes&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Accessories&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/nav&gt; 1234567891011121314151617181920.list1 ul &#123; /*强制ul包围浮动的li元素*/ overflow:hidden;&#125;.list1 li &#123; /*让li元素水平排列*/ float:left; /*去掉项目符号*/ list-style-type:none;&#125;.list1 a &#123; /*让链接填满li元素*/ display:block; padding:0 16px; /*去掉链接的下划线*/ text-decoration:none; color:#999;&#125;.list1 li + li a &#123;border-left:1px solid #aaa;&#125;.list1 a:hover &#123;color:#555;&#125; 浮动让li元素从垂直变成水平，display:block让链接从收缩变成扩张，从而整个li元素都变成了可以点击的。另外，选择符li + li a为除第一个链接之外的每个链接左侧都加了一条竖线，作为视觉分隔线。好啦，可以讲更复杂的样式了。 下拉菜单三级菜单的实现，是通过ul的三层嵌套来实现的 12345678910111213141516171819202122232425262728&lt;nav class=\"multi_drop_menu\"&gt; &lt;!-- 一级开始 --&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Power&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Money&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Love&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Fame&lt;/a&gt; &lt;!-- 二级开始 --&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Sports Star&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Movie Star&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Rock Star&lt;/a&gt; &lt;!-- 三级开始 --&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Bruce Springsteen&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Bono&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Mick Jagger&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Bob Dylan&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 三级结束 --&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Web Designer&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 二级结束 --&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 一级结束 --&gt;&lt;/nav&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*顶级菜单样式*//*添加视觉样式*/.multi_drop_menu &#123;font:1em helvetica, arial, sans-serif;&#125;.multi_drop_menu a &#123; /*让链接充满列表项*/ display:block; /*文本颜色*/ color:#555; /*背景颜色*/ background-color:#eee; /*链接的内边距*/ padding:.2em 1em; /*分隔线宽度*/ border-width:3px; /*可以有颜色，也可以透明*/ border-color:transparent;&#125;.multi_drop_menu a:hover &#123; /*悬停时文本颜色*/ color:#fff; /*悬停时背景色*/ background-color:#aaa;&#125;.multi_drop_menu a:active &#123; /*点击时背景变色*/ background:#fff; /*点击时文本变色*/ color:#ccc;&#125;/*添加功能样式*/.multi_drop_menu * &#123;margin:0; padding:0;&#125;/*强制ul包围li*/.multi_drop_menu ul &#123;float:left;&#125;.multi_drop_menu li &#123; /*水平排列菜单项*/ float:left; /*去掉默认的项目符号*/ list-style-type:none; /*为子菜单提供定位上下文*/ position:relative;&#125;.multi_drop_menu li a &#123; /*让链接填充列表项*/ display:block; /*给每个链接添加一个右边框*/ border-right-style:solid; /*背景只出现在内边距区域后面*/ background-clip:padding-box; /*去掉链接的下划线*/ text-decoration:none;&#125;.multi_drop_menu li:last-child a &#123;border-right-style:none;&#125;/*临时隐藏低级菜单*/.multi_drop_menu li ul &#123;display:none;&#125;  常用场景技能实现 居中12345678910111213141516171819p&#123; margin:20px auto;&#125;/*让文本和图片垂直居中*/div &#123; height:150px; width:250px; border:2px solid #aaa; margin:20px auto; background-image:url(images/turq_spiral_150.png); background-repeat:no-repeat; background-position:50% 50%;// text-align: center;// line-height: 250px;//&#125;li &#123; /*去掉列表项目符号*/ list-style-type:none;&#125;","categories":[{"name":"css","slug":"css","permalink":"http://hillychen.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://hillychen.github.io/tags/css/"}],"keywords":[{"name":"css","slug":"css","permalink":"http://hillychen.github.io/categories/css/"}]},{"title":"c/cpp学习笔记","slug":"c-cpp学习笔记","date":"2017-04-16T09:03:39.000Z","updated":"2017-04-16T14:33:58.000Z","comments":true,"path":"2017/04/16/c-cpp学习笔记/","link":"","permalink":"http://hillychen.github.io/2017/04/16/c-cpp学习笔记/","excerpt":"","text":"从大学刚学习c/cpp以来，几年过去了，但是由于大学没有好好深入学习研究c/cpp以及算法，挺后悔的。所以奉劝计算机专业的学生，大学不应该过早步入各种开发的步调，而忽略c/cpp、算法、基础专业知识的学习。其实一开始，最重要的就是把基础打扎实了，编程的思维方式和动手能力很重要，如何将现实问题，通过算法建模转化为代码才是至关重要的，可以视为灵魂。所以我把自己学习的过程做记录，没事的时候仔细体会，别有一番风味，每次也会有不一样的体会。 指针 先以一段代码开始12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; // create two arrays we care about int ages[] = &#123;23, 43, 12, 89, 2&#125;; char *names[] = &#123; \"Alan\", \"Frank\", \"Mary\", \"John\", \"Lisa\" &#125;; // safely get the size of ages int count = sizeof(ages) / sizeof(int); int i = 0; // first way using indexing for(i = 0; i &lt; count; i++) &#123; printf(\"%s has %d years alive.\\n\", names[i], ages[i]); &#125; printf(\"---\\n\"); // setup the pointers to the start of the arrays int *cur_age = ages; char **cur_name = names; // second way using pointers for(i = 0; i &lt; count; i++) &#123; printf(\"%s is %d years old.\\n\", *(cur_name+i), *(cur_age+i)); &#125; printf(\"---\\n\"); // third way, pointers are just arrays for(i = 0; i &lt; count; i++) &#123; printf(\"%s is %d years old again.\\n\", cur_name[i], cur_age[i]); &#125; printf(\"---\\n\"); // fourth way with pointers in a stupid complex way for(cur_name = names, cur_age = ages; (cur_age - ages) &lt; count; cur_name++, cur_age++) &#123; printf(\"%s lived %d years so far.\\n\", *cur_name, *cur_age); &#125; return 0;&#125; 上面的代码很好的诠释了指正的工作原理，首先 在你的计算机中开辟一块内存。 将ages这个名字“指向”它的起始位置。 通过选取ages作为基址，并且获取位置为i的元素，来对内存块进行索引。 将ages+i处的元素转换成大小正确的有效的int，这样就返回了你想要的结果：下标i处的int。 指针仅仅是指向计算机中的某个地址，并带有类型限定符，所以你可以通过它得到正确大小的数据，指针的用途就是让你手动对内存块进行索引，一些情况下数组并不能做到。绝大多数情况中，你可能打算使用数组，但是一些处理原始内存块的情况，是指针的用武之地。指针向你提供了原始的、直接的内存块访问途径，让你能够处理它们。指针有四个最基本的操作： 向OS申请一块内存，并且用指针处理它。这包括字符串，和一些你从来没见过的东西，比如结构体。 通过指针向函数传递大块的内存（比如很大的结构体），这样不必把全部数据都传递进去。 获取函数的地址用于动态调用。 对一块内存做复杂的搜索，比如，转换网络套接字中的字节，或者解析文其实当我们在阅读别人的代码或者自己运用指正，只要把下面这几点牢记于心，就应该没问题，一步一步去拆解理解： type *ptr：type类型的指针，名为ptr *ptr：ptr所指向位置的值 *(ptr + i)：ptr所指向位置加上i）的值 &amp;thing：thing的地址 type *ptr = &amp;thing：名为ptr，type类型的指针，值设置为thing的地址 ptr++：自增ptr指向的位置* 结构体 从一段代码搞起：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct Person &#123; char *name; int age; int height; int weight;&#125;;struct Person *Person_create(char *name, int age, int height, int weight)&#123; struct Person *who = malloc(sizeof(struct Person)); assert(who != NULL); //使用strdup来复制字符串name，是为了确保结构体真正拥有它。strdup的行为实际上类似malloc但是它同时会将原来的字符串复制到新创建的内存。 who-&gt;name = strdup(name); who-&gt;age = age; who-&gt;height = height; who-&gt;weight = weight; return who;&#125;void Person_destroy(struct Person *who)&#123; assert(who != NULL); free(who-&gt;name); free(who);&#125;void Person_print(struct Person *who)&#123; printf(\"Name: %s\\n\", who-&gt;name); printf(\"\\tAge: %d\\n\", who-&gt;age); printf(\"\\tHeight: %d\\n\", who-&gt;height); printf(\"\\tWeight: %d\\n\", who-&gt;weight);&#125;int main(int argc, char *argv[])&#123; // make two people structures struct Person *joe = Person_create( \"Joe Alex\", 32, 64, 140); struct Person *frank = Person_create( \"Frank Blank\", 20, 72, 180); // print them out and where they are in memory printf(\"Joe is at memory location %p:\\n\", joe); Person_print(joe); printf(\"Frank is at memory location %p:\\n\", frank); Person_print(frank); // make everyone age 20 years and print them again joe-&gt;age += 20; joe-&gt;height -= 2; joe-&gt;weight += 40; Person_print(joe); frank-&gt;age += 20; frank-&gt;weight += 20; Person_print(frank); // destroy them both so we clean up Person_destroy(joe); Person_destroy(frank); return 0;&#125; 其实结构体就相当于数据库中的一行或者OOP语言中的类一样* ##","categories":[{"name":"c/cpp","slug":"c-cpp","permalink":"http://hillychen.github.io/categories/c-cpp/"}],"tags":[{"name":"c/cpp","slug":"c-cpp","permalink":"http://hillychen.github.io/tags/c-cpp/"}],"keywords":[{"name":"c/cpp","slug":"c-cpp","permalink":"http://hillychen.github.io/categories/c-cpp/"}]},{"title":"Hexo博客迁移部署到oschina(开源中国)&&codingNet(码市)","slug":"Hexo博客迁移部署到oschina-开源中国-coding-码云","date":"2017-04-08T16:14:29.000Z","updated":"2017-04-08T16:32:56.000Z","comments":true,"path":"2017/04/09/Hexo博客迁移部署到oschina-开源中国-coding-码云/","link":"","permalink":"http://hillychen.github.io/2017/04/09/Hexo博客迁移部署到oschina-开源中国-coding-码云/","excerpt":"","text":"这两天突然发现github.io的pags服务挂掉了,导致博客登录不上，为了防止以后类似情况的发生，决定把博客部署到国内的一些托管平台，比如开源中国和码市。因为二者都支持项目开启pages服务，所以迁移起来很简单; step1、新建项目仓 到开源中国和码市申请账号登录新建项目 在新建项目的时候，对于pages项目，项目的名称一定要跟用户名一致，不然后面当博客源码推送到仓库上的时候，访问的时候会遇到静态资源都加载失败的情况； 把项目的pages功能开启，默认使用master分支； step2、修改修改hexo配置 打开博客根目录的_config.yml文件，找到： 123456789# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'#url: http://hillychen.github.io# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/HillyChen/HillyChen.github.io branch: master 修改为(根据自己的仓库地址修改,其中增加了开源中国仓库地址和码云的仓库地址)： 123456789101112## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://git.oschina.net/chenxushan/chenxushan.git#url: http://hillychen.github.io#url: https://git.coding.net/hilly/hilly.git# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git #repo: https://github.com/HillyChen/HillyChen.github.io repo: https://git.oschina.net/chenxushan/chenxushan.git #repo: https://git.coding.net/hilly/hilly.git branch: master 然后执行下面命令，以重新生成baidusitemap.xml。 1hexo generate -d","categories":[{"name":"博客迁移","slug":"博客迁移","permalink":"http://hillychen.github.io/categories/博客迁移/"}],"tags":[{"name":"博客迁移","slug":"博客迁移","permalink":"http://hillychen.github.io/tags/博客迁移/"}],"keywords":[{"name":"博客迁移","slug":"博客迁移","permalink":"http://hillychen.github.io/categories/博客迁移/"}]},{"title":"计算机专业基础知识","slug":"计算机专业基础知识","date":"2017-04-07T15:12:31.000Z","updated":"2017-04-09T07:25:50.000Z","comments":true,"path":"2017/04/07/计算机专业基础知识/","link":"","permalink":"http://hillychen.github.io/2017/04/07/计算机专业基础知识/","excerpt":"","text":"从事IT行业的人，可能有一部分人不是科班出身，或者即使是科班出身，可能对计算机的一些基础理论知识掌握的不是很牢靠，目前国内的计算机学院的专业课程中最重要的就是这四门：计算机组成、操作系统、数据结构、计算机网络。这四门也是目前计算机考研所涉及的，很重要，也很基础，虽然现在很多软件开发人员在工作中都不涉及这些知识，但是对于大公司来说，要想深入技术领域产品的研发，这些知识是很重要的，所以对于打算一直走技术路线的人来说，职业生涯很有必要抽出时间进行学习。八个字：“巩固、充实、深入、探索”。下面是整理的一些思维导图。 计算机组成 计算机系统概述 存储器 指令系统 中央处理器 总线 输入输出系统 操作系统 进程管理 处理机调度(CPU) 进程同步与互斥 死锁 内存管理 文件管理","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://hillychen.github.io/categories/计算机基础/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://hillychen.github.io/tags/计算机基础/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://hillychen.github.io/categories/计算机基础/"}]},{"title":"设计师和程序员必备：全世界最著名的 icons 网站","slug":"设计师和程序员必备：全世界最著名的-icons-网站","date":"2017-04-05T15:05:33.000Z","updated":"2017-07-01T15:29:14.000Z","comments":true,"path":"2017/04/05/设计师和程序员必备：全世界最著名的-icons-网站/","link":"","permalink":"http://hillychen.github.io/2017/04/05/设计师和程序员必备：全世界最著名的-icons-网站/","excerpt":"","text":"对于网页开发者或者是设计师，素材收集是很重要的一个环节，特别是对于我这种有强迫症的人，做任何工作，都会提前收集很多的素材，对于一些图标、图片、色彩等的设计往往会占据很多时间，所以好的素材网站或者积累是很重要的，下面就是全球一些著名的icons网站，以后会更新设计相关的其他网站收集，比如色彩； 全世界最著名的 icons 网站 icons8:拥有 42,800 个免费图标，提供各个平台的基础图标与分类图标，其特色是大小和颜色随意自定义。 iconfinder:哥本哈根一个团队做的 icon 专业图标网站，拥有 1563889 个图标和37058图标集，是最专业的 icon 图标网站之一。 iconfont:国内功能很强大且图标内容很丰富的矢量图标库,提供矢量图标下载、在线存储、格式转换等功能，是阿里妈妈 MUX 组业余时间做的的矢量图标管理、交流平台。 Noun Project:国外三位设计师 2010 创建一个收录、并可免费使用高清符号图示的媒体库，包含25个语言版本，每天都有来自世界各地的设计师提交新 icon。 Flaticon:搜索海量扁平化图标，让图标搜索和转换变得非常简单和快速，并提供常用格式 SVG、PSD 源文件和 PNG 下载。 iconstore:Icon Store 提供高质量的免费的/收费的图标，包括卡通风格图标，极简主义图标，扁平化设计风格图标，手绘风格图标，像素风格图标等等，也包括各种类型主题图标，比如圣诞节主题图标，情人节主题图标，天气图标，办公室图标,动物图标，美容美发图标等等。 Material icons:Google 官方的扁平化图标手册，收集了多达10,000+图标，包括了网页，排版，音频，商务等等主题的绝大多数图标。格式包括SVG,PNG,ICON,以及字体图标，你可以在网页中轻松引用图标。 swifticons:覆盖 20 个大类包含 2264 个高质量图标 flat-icon-design:一个日本的免费扁平化设计图示网站，总数量大约有 500 个左右！网站提供的图示风格设计都很简约、可爱，非常适合使用于网页设计、应用程序开发或投影片报告，而且这些图示明确标示为「可以作为商业用途」，网站开放 Illustrator AI、EPS、JPEG、PNG 和 SVG 五种格式下载。 Font-Awesome:一套专门为 Twitter Boostrap 设计的图标字体库。这套图标字体集几乎囊括了网页中可能用到的所有图标，除了包括 Twitter Boostrap 的默认图标外，还有社交网络图标、Web 应用程序图标和编辑器图标等等，可以免费用于商业项目。 sketch:sketch 设计素材开发 clipboardjs caniuse overapi imooc modernizr 960Grid","categories":[{"name":"UI","slug":"UI","permalink":"http://hillychen.github.io/categories/UI/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://hillychen.github.io/tags/UI/"}],"keywords":[{"name":"UI","slug":"UI","permalink":"http://hillychen.github.io/categories/UI/"}]},{"title":"学习vue.js实现的一个小demo","slug":"学习vue-js实现的一个小demo","date":"2017-03-18T14:18:13.000Z","updated":"2017-03-18T14:25:07.000Z","comments":true,"path":"2017/03/18/学习vue-js实现的一个小demo/","link":"","permalink":"http://hillychen.github.io/2017/03/18/学习vue-js实现的一个小demo/","excerpt":"","text":"学习vue.js最好的方法，当然首要就是vue官方文档，作为一个由中国开发者开发的一个前端框架，目前github上的start数量已经四千多，所以还是比较强悍的，我在学习的时候，边看文档，便去实现一个特定场景的功能，就是对一个表格数据进行增、删、改、查、搜索;鄙人水平有限，仅供入门者交流学习，望大神别吐槽！哈哈！demo,点击预览 实现过程界面设计vue.js在本demo的核心代码实现","categories":[],"tags":[],"keywords":[]},{"title":"PHP学习总结","slug":"PHP学习总结","date":"2017-03-18T10:40:32.000Z","updated":"2017-03-19T15:06:02.000Z","comments":true,"path":"2017/03/18/PHP学习总结/","link":"","permalink":"http://hillychen.github.io/2017/03/18/PHP学习总结/","excerpt":"","text":"知识在乎不断的积累和总结，好记性不如烂笔头.读各种书，以博客以记之，为了自己日后学习查阅，也可以和远方来的朋友分享交流。 PHP中的常用函数 其实学习PHP或者Python，最终要的一点就是要熟悉一些常用库或者函数，这样在应用的时候才能游刃有余，下面总结一下常用的函数查看数据类型 gettype(传入一个变量) 能够获得变量的类型 var_dump(传入一个变量) 输出变类型和值判断数据类型 is_int/bool/float/string/array/object/null/resource(资源)/scalar(标量)/numeric(是否为数值类型)/callable(是否为函数)1234$float = 88.8;$type = gettype($float);var_dump($float);echo $type; 强制类型转换 强制类型转换有三种方式： 用后面的三个函数可以完成类型转换，intval()、floatval()、strval() 变量前加上()里面写上类型，将它转换后赋值给其他变量 settype(变量，类型) 直接改变量本身 常量和变量常量 定义 define(常量名，常量值)；defined()函数来做安全机制系统的一些常量： 常量明 说明 常量明 说明 LINE 当前所在的行 FILE 当前文件在服务器的路径 FUNCTIOIN 当前函数名 CLASS 当前类名 METHOD 当前成员方法名 PHP_OS PHP运行的操作系统 PHP_VERSION 当前PHP的版本 TRAIT Trait 的名字,php5.4新加 DIR 文件所在的目录 NAMESPACE 当前命名空间的名称（区分大小写 123456define('MY_NAME','PHP');echo MY_NAME;//下面是错误的调用方式echo '我的名字是MY_NAME';//正确的调用方式该这么写echo '我的名字是' . MY_NAME; 变量 变变量其实就是——已声明的变量前，再上变量符 123456789$shu = 'biao';$biao = 'wo';$wo = 'test';$test = 'sina';$sina = 'zhongguo';$zhongguo = 'china';$china = '我爱你';//别运行，自己去推理一下代码。也写几个可变变量玩玩吧！echo $$$$$shu;(输出是zhongguo) PHP的外部变量是PHP 在使用过程中规定好的一些变量:应有场景：user.html 123456789101112&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"reg.php\" method=\"get\"&gt; &lt;input type=\"text\" name=\"username\" /&gt; &lt;input type=\"password\" name=\"pwd\" /&gt; &lt;input type=\"submit\" value=\"提交\" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; reg.php 12345678//$_GET后面加上中括号，将username作为字符串放在中括号里面，就得到了表单里面的&lt;input type=\"text\" name=\"username\" /&gt; 的值$u = $_GET['username'];$u = $_POST['username'];echo $u.'&lt;br /&gt;';//$_GET['pwd'] 得到表单&lt;input type=\"password\" name=\"pwd\" /&gt; 的值$passwd = $_GET['pwd'];echo $passwd.'&lt;br /&gt;'; 全局变量名 功能说明 全局变量名 功能说明 $_COOKIE 得到会话控制中cookie传值 $_SESSION 得到会话控制中session的值 $_FILES 得到文件上传的结果 $_GET 得到get传值的结果 $_POST 得到post传值的结果 $_REQUEST 即能得到get的传值结果，也能得到post传值的结果 一些常用的环境变量的键名和值对应的意思： 键名 含义 $_SERVER[“REQUEST_METHOD”] 请求当前PHP页面的方法 $_SERVER[“REQUEST_URI”] 请求的URI $_SERVER[“SERVER_SOFTWARE”] 用的是哪一种服务器 $_SERVER[“REMOTE_ADDR”] 客户的IP地址 $_SERVER[“SERVER_ADDR”] 当前服务器的IP地址 $_SERVER[“SCRIPT_FILENAME”] 当前请求文件的路径 $_SERVER[“HTTP_USER_AGENT”] 当前访问这个网址的电脑和浏览器的情况 $_SERVER[“HTTP_REFERER”] 上级来源（用户从哪个地址进入当前网页的） $_SERVER[“REQUEST_TIME”] 当前请求时间 变量引用(类似于C语言指正)12345678$fo = 5;//注意，加上了一个&amp;符哟$bar = &amp;$fo;$bar = 6;//$bar的结果为6echo $bar.'&lt;br /&gt;';//$fo的结果为6echo $fo.'&lt;br /&gt;'; 三元运算符 符号 说明 $x? 真代码段:假代码段 判断是否为真假 ? 真情况 : 假情况; ``（反引号） 反引号中间插代命令，执行系统命令，等价于shell_exec函数 @ 单行抑制错误，把这一行的错误不让它显示出来了，效率低不建议使用 =&gt; 数组下标访问符 -&gt; 对象访问符 instanceof 判断某个对象是否来自某个类，如果是的返回true，如果不是返回false 函数回调函数12345678910111213141516171819202122function woziji($one,$two,$func)&#123; //我规定：检查$func是否是函数，如果不是函数停止执行本段代码，返回false if(!is_callable($func))&#123; return false; &#125; //我把$one、$two相加，再把$one和$two传入$func这个函数中处理一次 //$func是一个变量函数，参见变量函数这一章 echo $one + $two + $func($one,$two);&#125;//我们定义几个函数试试function plusx2( $foo , $bar)&#123; $result = ($foo+$bar)*2; return $result;&#125;function jian( $x , $y )&#123; $result = $x - $y; return $result;&#125;//调用一下函数，woziji，向里面传入参数试试echo woziji(20,10,'plusx2');//将plusx2改成jian试试结果echo woziji(20,10,'jian'); 变量函数1234567891011function demo()&#123; echo '天王盖地虎';&#125;function test()&#123; echo '小鸡炖蘑菇';&#125;$fu = 'demo';//把$fu变为了demo,把demo后加上了一个括号，就执行函数了$fu();//把$fu的值改为test字符串再试试？ 匿名函数1234567891011121314151617181920212223//1.变量函数式的匿名函数$greet = function($name)&#123;echo $name.'，你好';&#125;;$greet('明天');$greet('PHP学院');//2.回调式的匿名函数function woziji($one,$two,$func)&#123; //我规定：检查$func是否是函数，如果不是函数停止执行本段代码，返回false if(!is_callable($func))&#123; return false; &#125; //我把$one、$two相加，再把$one和$two传入$func这个函数中处理一次 //$func是一个变量函数，参见变量函数这一章 echo $one + $two + $func($one,$two);&#125;woziji(20,30,function( $foo , $bar)&#123; $result = ($foo+$bar)*2; return $result; &#125;); 内部函数1234567891011121314151617&lt;?phpfunction foo()&#123; echo '我是函数foo哟，调一下我才会执行定义函数bar的过程&lt;br /&gt;'; function bar() &#123; echo '在foo函数内部有个函数叫bar函数&lt;br /&gt;'; &#125;&#125;//现在还不能调用bar()函数，因为它还不存在bar();foo();//现在可以调用bar()函数了，因为foo()函数的执行使得bar()函数变为已定义的函数bar();//再调一次foo()看看是不是会报错？foo();?&gt; 变量作用域 我们将函数体外的变量通过$GLOBALS拿到了函数体使用。所以，打破了函数外的变量不能在函数体内使用的限定。12345678$one = 10;function demo()&#123; $two = 100; $result = $two + $GLOBALS['one']; return $result;&#125;//你会发现结果变成了110echo demo(); 使用内置函数 主要掌握如何使用内置函数，就是会看PHP官方文档使用函数的重点是三块： 了解函数的功能，特别是常用函数的功能 了解函数的参数 了解函数的返回值针对上面的三块，讲解6个函数，这6个函数，概况了函数的基本用法的全部注意事项： 直接返回布尔型，如bool copy () 带有MIXED参数的函数如何调用。Mixed表示任何类型的数据。如Array_unshift() 参数中带有&amp;符的参数，一定要传一个变量做为参数。函数里面改变了他的值。 带有[]的参数，表示可选项。 带有…的参数，表示可以传任意多个参数。 带有callback的参数，表示回调函数。需要传一个函数进来。Array_map() 函数支持的版本你要了解 1.bool copy ( string $source , string $dest [, resource $context ]) 这个函数的功能为： 拷备一个文件返回值为为： bool型值，就是成功返回true，失败返回false参数为： 两个字符串的值，一个是copy的源文件，一个为目标文件。第三个参数可选的，不常用，我们不管它。12345$file = 'example.txt';$newfile = 'example.txt.bak';if (!copy($file, $newfile)) &#123; echo \"failed to copy $file...\\n\";&#125; 2.int array_unshift ( array &amp;$array , mixed $value1 [, mixed $… ] ) Mixed表示任何类型的数据。功能： 操作一个数组，向数组中之前插入其他类型的参数。返回值： int 类型，可能就是插入成功最后的个数参数： 第一个参数为&amp;符，也就是在操作的过程中，改变了第一个参数的值。引用传参。也就是操作这个数组，向这个数组中传入参数。会直接改变这个数组的值。第二个参数为mixed，因为数组可以存入多个不同的类型.mixed是指混合的意思。因此，mixed是指可传入任意类型。第三个数数加了中括号，我们所有遇到中括号的。都是指后面的参数可传，也可以不传。第四，最后还看到了三个…(省略号)。代表可以传入任意多个参数。1234567891011$queue = array(\"orange\", \"banana\");array_unshift($queue, \"apple\", \"raspberry\");print_r($queue);// The above example will output:// Array// (// [0] =&gt; apple// [1] =&gt; raspberry// [2] =&gt; orange// [3] =&gt; banana// ) 3、bool array_walk ( array &amp;$array , callable $callback [, mixed $userdata = NULL ] )功能：传入一个回调函数，将数组的原来的组操作，并且发生变化。返回值：bool 值 也就是意味着，提示成功或者失败参数：第一个参数是要操作的数组。第二个参数是callback 代表着可以传入函数或者匿名函数。12345678910111213141516171819202122232425$fruits = array(\"d\" =&gt; \"lemon\", \"a\" =&gt; \"orange\", \"b\" =&gt; \"banana\", \"c\" =&gt; \"apple\");function test_alter(&amp;$item1, $key, $prefix)&#123; $item1 = \"$prefix: $item1\";&#125;function test_print($item2, $key)&#123; echo \"$key. $item2&lt;br /&gt;\\n\";&#125;echo \"Before ...:\\n\";array_walk($fruits, 'test_print');array_walk($fruits, 'test_alter', 'fruit');echo \"... and after:\\n\";array_walk($fruits, 'test_print');// The above example will output:// Before ...:// d. lemon// a. orange// b. banana// c. apple// ... and after:// d. fruit: lemon// a. fruit: orange// b. fruit: banana// c. fruit: apple 文件包含函数 函数 包含失败 特点 Inlcude 返回一条警告 文件继续向下执行。通常用于动态包含 Require 一个致命的错 代码就不会继续向下执行。通常包含极为重要的文件，整个代码甭想执行 Include_once 返回一条警告 除了原有include的功能以外，它还会做once检测，如果文件曾经已经被被包含过，不再包含 Require_once 一个致命的错 除了原的功能一外，会做一次once检测，防止文件反复被包含 日期常用函数 在正式学习日期函数前大家要了解几个概念: 时区:1884年在华盛顿召开国际经度会议时，为了克服时间上的混乱，规定将全球划分为24个时区。在中国采用首都北京所在地东八区的时间为全国统一使用时间。 世界时:如果对国际上某一重大事情，用地方时间来记录，就会感到复杂不便．而且将来日子一长容易搞错。因此，天文学家就提出一个大家都能接受且又方便的记录方法，那就是以格林尼治（英国某地区）的地方时间为标准。 unix时间戳:从Unix纪元（1970 年 1月1日零时）开始到一个时间经过的秒数。时间函数有： 设置时区： date_default_timezone_get() date_default_timezone_set()123456//定义一下时区常量，以后你可以放到配置文件里define('TIME_ZONE','Asia/shanghai');//执行函数date_default_timezone_set(TIME_ZONE);echo date_default_timezone_get ();echo date('Y-m-d H:i:s'); time()获取当前的unix时间戳:time()获取当前的unix时间戳 getdate获取当前系统时间 12345678910111213141516171819202122232425262728$mytime= getdate()； print_r( $mytime)；// Array// (// [seconds] =&gt; 1 //秒// [minutes] =&gt; 10 //分钟// [hours] =&gt; 17 //小时// [mday] =&gt; 18 //日// [wday] =&gt; 0 //星期中的第几天// [mon] =&gt; 1 //月// [year] =&gt; 2015 //年// [yday] =&gt; 17 //年中的第几天// [weekday] =&gt; Sunday //星期// [month] =&gt; January //月份// [0] =&gt; 1421597401 //时间戳// )$mytime = getdate();echo \"年 :\".$mytime['year'].\"\\n\";echo \"月 :\".$mytime['mon'].\"\\n\";echo \"日 :\".$mytime['mday'].\"\\n\";echo \"时 :\".$mytime['hours'].\"\\n\";echo \"分 :\".$mytime['minutes'].\"\\n\";echo \"秒 :\".$mytime['seconds'].\"\\n\";echo \"一个小时中的第几钟 :\".$mytime['minutes'].\"\\n\";echo \"这是一分钟的第几秒 :\".$mytime['seconds'].\"\\n\";echo \"星期名称 :\".$mytime['weekday'].\"\\n\";echo \"月份名称 :\".$mytime['month'].\"\\n\";echo \"时间戳 :\".$mytime[0].\"\\n\"; 日期验证函数:bool checkdate ( int $month , int $day , int $year ) mktime()函数可以对一个日期和时间获得一个本地化时间戳:int mktime (int $hour [, int $minute [, int $second [, int $month [, int $day [. int$year [, int $.is_dstl.l } ] ] 31 ) 将英文文本的日期时间描述解析为 Unix 时间戳:int strtotime ( string $time [, int $now = time() ] ) 程序执行时间检测,microtime()这个函数，能够返回当前 Unix 时间戳和微秒数:mixed microtime ([ bool $get_as_float ] ) 字符串常用函数声明： 内容参考：《7天学会PHP》","categories":[{"name":"PHP","slug":"PHP","permalink":"http://hillychen.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://hillychen.github.io/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"http://hillychen.github.io/categories/PHP/"}]},{"title":"算法学习01","slug":"算法学习01","date":"2017-03-12T14:08:09.000Z","updated":"2017-06-02T16:23:06.000Z","comments":true,"path":"2017/03/12/算法学习01/","link":"","permalink":"http://hillychen.github.io/2017/03/12/算法学习01/","excerpt":"","text":"底子薄、内心厚、精诚所至、金石为开、加油！ 数组问题合并两个有序列(Merge two sorted arrays) 问题描述：给两个有序的数组，然后给出算法，使得两个数组合并成一个有序数组算法：1234567891011121314151617181920212223242526272829303132333435363738394041424344// C++ program to merge two sorted arrays/#include&lt;iostream&gt;using namespace std;// Merge arr1[0..n1-1] and arr2[0..n2-1] into// arr3[0..n1+n2-1]void mergeArrays(int arr1[], int arr2[], int n1, int n2, int arr3[])&#123; int i = 0, j = 0, k = 0; // Traverse both array while (i&lt;n1 &amp;&amp; j &lt;n2) &#123; // Check if current element of first // array is smaller than current element // of second array. If yes, store first // array element and increment first array // index. Otherwise do same with second array if (arr1[i] &lt; arr2[j]) arr3[k++] = arr1[i++]; else arr3[k++] = arr2[j++]; &#125; // Store remaining elements of first array while (i &lt; n1) arr3[k++] = arr1[i++]; // Store remaining elements of second array while (j &lt; n2) arr3[k++] = arr2[j++];&#125;// Driver codeint main()&#123; int arr1[] = &#123;1, 3, 5, 7&#125;; int n1 = sizeof(arr1) / sizeof(arr1[0]); int arr2[] = &#123;2, 4, 6, 8&#125;; int n2 = sizeof(arr2) / sizeof(arr2[0]); int arr3[n1+n2]; mergeArrays(arr1, arr2, n1, n2, arr3); cout &lt;&lt; \"Array after merging\" &lt;&lt;endl; for (int i=0; i &lt; n1+n2; i++) cout &lt;&lt; arr3[i] &lt;&lt; \" \"; return 0;&#125; 分析：Time Complexity : O(n1 + n2)Auxiliary Space : O(n1 + n2)","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://hillychen.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://hillychen.github.io/tags/algorithm/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://hillychen.github.io/categories/algorithm/"}]},{"title":"javascript学习总结","slug":"javascript学习总结","date":"2017-03-12T14:06:51.000Z","updated":"2017-03-16T12:56:34.000Z","comments":true,"path":"2017/03/12/javascript学习总结/","link":"","permalink":"http://hillychen.github.io/2017/03/12/javascript学习总结/","excerpt":"","text":"","categories":[{"name":"javascript","slug":"javascript","permalink":"http://hillychen.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://hillychen.github.io/tags/javascript/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://hillychen.github.io/categories/javascript/"}]},{"title":"Git总结","slug":"Git总结","date":"2017-03-12T14:06:27.000Z","updated":"2017-03-12T14:38:11.000Z","comments":true,"path":"2017/03/12/Git总结/","link":"","permalink":"http://hillychen.github.io/2017/03/12/Git总结/","excerpt":"","text":"","categories":[{"name":"git","slug":"git","permalink":"http://hillychen.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://hillychen.github.io/tags/git/"}],"keywords":[{"name":"git","slug":"git","permalink":"http://hillychen.github.io/categories/git/"}]},{"title":"Mysql学习总结","slug":"Mysql学习总结","date":"2017-03-12T14:05:44.000Z","updated":"2017-05-29T14:18:52.000Z","comments":true,"path":"2017/03/12/Mysql学习总结/","link":"","permalink":"http://hillychen.github.io/2017/03/12/Mysql学习总结/","excerpt":"","text":"知识在乎不断的积累和总结，好记性不如烂笔头.读各种书，以博客以记之，为了自己日后学习查阅，也可以和远方来的朋友分享交流。 简介 MySQL 是一个关系数据库系统，支持 SQL 查询语言。 MySQL 可以是免费的，你不需要为它付费。 MySQL 系统的速度非常快，同样它的性能也是十分优良的。 MySQL 是一个管理简捷的数据库，它没有庞大而臃肿的可视化管理工具。 mysql基础命令1234567891011121314151617181920212223USE tablename;SHOW databases;SHOW tables;SHOW columns from tablename;--返回数据表的各个列及属性DESCRIBE tablename;--等价于上一句SHOW STATUS;--用于显示广泛的服务器状态信息;SHOW CREATE DATABASE,SHOW CREATE TABLE--分别用来显示创建特定数据库或表的MySQL语句;SHOW GRANTS;--用来显示授予用户(所有用户或特定用户)的安全权限;SHOW ERRORS,SHOW WARNINGS;--用来显示服务器错误或警告消息--进一步了解SHOW 请在mysql命令行实用程序中，执行命令 HELP SHOW;显示允许的SHOW语句。-- 检索SELECT colum_name FROM tablename;--检索多个列SELECT colum1,colum2,colum3 FROM tablename;--检索多个列SELECT * FROM tablename;SELECT DISTINCT vend_id FROM tablename;--返回不同(唯一)的vend_id行--检索指定行SELECT colum FROM tablename LIMIT 5;--LIMIT 5指示MySQL返回 不多于5行--为得出下一个5行，可指定要检索的开始行和行数SELECT colum FROM tablename LIMIT 5,5;--使用完全限定的表名SELECT tablename.column FROM databse.tablename;--在有些场景的时候，是需要这样的，多表查询的时候; 排序数据检索1234567SELECT column FROM tablename ORDER BY column;--按单列排序SELECT column1,column2,column3 FROM tablename ORDER BY column2,column3;--指定排序方向SELECT column FROM tablename ORDER BY column DESC;--降序排序SELECT column1,column2,column3 FROM tablename ORDER BY column2 DESC,column3;--默认是升序ASC-- 使用ORDER BY 和LIMIT组合可以选出最大和最小SELECT column FROM tablename ORDER BY column DESC LIMIT 1; 过滤数据123456SELECT column1,column2,column3 FROM tablename WHERE column1=value;-- WHERE子句的位置 在同时使用ORDERBY和WHERE子句时，应 该让ORDER BY位于WHERE之后，否则将会产生错误-- = 等于&lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 BETWEEN 在指定的两个值之间SELECT column1,column2,column3 FROM tablename WHERE column1 BETWEEN value1 AND value2;-- 空值检查SELECT column1,column2,column3 FROM tablename WHERE column1 IS NULL; 数据过滤12345678910-- 为了进行更强的过滤控制，MySQL允许给出多个WHERE子句。这些子 句可以两种方式使用:以AND子句的方式或OR子句的方式使用。-- AND操作符SELECT column1,column2,column3 FROM tablename WHERE column1=value1 AND column3 &lt; value2;-- OR操作符SELECT column1,column2,column3 FROM tablename WHERE column1=value1 OR column3 &lt; value2;SELECT column1,column2,column3 FROM tablename WHERE (column1 = value1 OR column1 = value2) AND column3 &lt; value2;--不加括号的话，存在优先级选择问题，可能不会产生预期的结果-- IN 操作符SELECT column1,column2,column3 FROM tablename WHERE column1 IN (value1,value2) ORDER BY column2;-- 和or功能相似，但是有点就是执行更快，逻辑更清晰，可以包含其他SELECT语句，使得能够更动态地建立WHERE子句-- NOT操作符SELECT column1,column2,column3 FROM tablename WHERE column1 NOT IN (value1,value2) ORDER BY column2; 用通配符进行过滤12345678910--LIKE操作符-- 通配符(wildcard) 用来匹配值的一部分的特殊字符--搜索模式(search pattern)由字面值、通配符或两者组合构成的搜索条件。-- 谓词 操作符何时不是操作符?答案是在它作为谓词(predi- cate)时。从技术上说，LIKE是谓词而不是操作符。虽然最终 的结果是相同的，但应该对此术语有所了解，以免在SQL文档 中遇到此术语时不知道。-- 百分号(%)通配符SELECT column1,column2,column3 FROM tablename WHERE column1 LIKE \"value%\";--以value为开头的结果SELECT column1,column2,column3 FROM tablename WHERE column1 LIKE \"%value%\";-- 所有包含value的-- 注意NULL 虽然似乎%通配符可以匹配任何东西，但有一个例 外，即NULL。即使是WHERE prod_name LIKE '%'也不能匹配 用值NULL作为产品名的行。-- 下划线(_)通配符-- 另一个有用的通配符是下划线(_)。下划线的用途与%一样，但下划线只匹配单个字符而不是多个字符。 正如所见，MySQL的通配符很有用。但这种功能是有代价的:通配 符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一 些使用通配符要记住的技巧。 不要过度使用通配符。如果其他操作符能达到相同的目的，应该 使用其他操作符 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用 在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起 来是最慢的 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。总之，通配符是一种极重要和有用的搜索工具，以后我们经常会用 到它。 用正则表达式 进行搜索123-- 基本字符匹配SELECT column1,column2,column3 FROM tablename WHERE column1 REGEXP '1000' ORDER BY column1;SELECT column1,column2,column3 FROM tablename WHERE column1 REGEXP '.1000' ORDER BY column1;--这里使用了正则表达式.000。.是正则表达式语言中一个特殊的字符。它表示匹配任意一个字符，因此，1000和2000都匹配 且返回。 LIKE与REGEXP 在LIKE和REGEXP之间有一个重要的差别。请 看以下两条语句:12SELECT column1,column2,column3 FROM tablename WHERE column1 LIKE '.1000' ORDER BY column1;SELECT column1,column2,column3 FROM tablename WHERE column1 REGEXP '1000' ORDER BY column1; 如果执行上述两条语句，会发现第一条语句不返回数据，而第 二条语句返回一行。为什么?正如第8章所述，LIKE匹配整个列。如果被匹配的文本在列值 中出现，LIKE将不会找到它，相应的行也不被返回(除非使用 通配符)。而REGEXP在列值内进行匹配，如果被匹配的文本在 列值中出现，REGEXP将会找到它，相应的行将被返回。这是一 个非常重要的差别。那么，REGEXP能不能用来匹配整个列值(从而起与LIKE相同的作用)?答案是肯定的，使用^和$定位符(anchor)即可.匹配不区分大小写 MySQL中的正则表达式匹配(自版本 3.23.4后)不区分大小写(即，大写和小写都匹配)。为区分大 小写，可使用BINARY关键字，如WHERE prod_name REGEXP BINARY ‘JetPack .000’。123456789--进行OR匹配：为搜索两个串之一(或者为这个串，或者为另一个串)，使用|，如下所示SELECT column1,column2,column3 FROM tablename WHERE column1 REGEXP '1000|2000' ORDER BY column1;-- 匹配几个字符之一两个以上的OR条件 可以给出两个以上的OR条件。例如， '1000 | 2000 | 3000'将匹配1000或2000或3000。--匹配几个字符之一SELECT column1,column2,column3 FROM tablename WHERE column1 REGEXP '[123] tom' ORDER BY column1;--1 ton和2 ton都匹配且返回-- 字符集合也可以被否定，即，它们将匹配除指定字符外的任何东西。 为否定一个字符集，在集合的开始处放置一个^即可。因此，尽管[123] 匹配字符1、2或3，但[^123]却匹配除这些字符外的任何东西。-- 匹配范围-- 集合可用来定义要匹配的一个或多个字符。例如，下面的集合将匹 配数字0到9:[0123456789],为简化这种类型的集合，可使用-来定义一个范围。下面的式子功能 上等同于上述数字列表:[0-9],[a-z]匹配任意字母字符道理类似-- 匹配特殊字符，要用\\\\转移，\\\\.，代表搜索含有.字符的 匹配字符类:存在找出你自己经常使用的数字、所有字母字符或所有数字字母字 符等的匹配。为更方便工作，可以使用预定义的字符集，称为字符类(character class)。 [:alnum:]:任意字母和数字(同[a-zA-Z0-9]) [:alpha:]: 任意字符(同[a-zA-Z]) [:blank:]:空格和制表(同[\\t]) [:cntrl:]:ASCII控制字符(ASCII 0到31和127) [:digit:]:任意数字(同[0-9]) [:graph:]:与[:print:]相同，但不包括空格 [:lower:]:任意小写字母(同[a-z]) [:print:]:任意可打印字符 [:punct:]:既不在[:alnum:]又不在[:cntrl:]中的任意字符 [:space:]:包括空格在内的任意空白字符(同[\\f\\n\\r\\t\\v]) [:upper:]:任意大写字母(同[A-Z]) [:xdigit:]:任意十六进制数字(同[a-fA-F0-9])匹配多个实例： 元字符 说明 * 0个或多个匹配 + 1个或多个匹配(等于{1,}) ？ 0个或1个匹配(等于{0,1}) {n} 指定数目的匹配 {n,} 不少于指定数目的匹配 {n,m} 匹配数目的范围(m不超过255) 举例：正则表达式\\([0-9] sticks?\\)：\\(匹配)，[0-9]匹配任意数字(这个例子中为1和5)，sticks?匹配stick 和sticks(s后的?使s可选，因为?匹配它前面的任何字符的0次或1次出 现)，\\)匹配)。没有?，匹配stick和sticks会非常困难。[[:digit:]]{4}：匹配连在一起的任意4位数字定位符| 元字符 | 说明 || :————-: |:————-:||^|文本的开始||$|文本的结尾||[[:&lt;:]]|词的开始||[[:&gt;:]]|词的结尾|^[0-9\\.]只在.或任意数字为串中第一个字符时才匹配它们 创建计算字段 存储在数据库表中的数据一般不是应用程序所需要的格式。下面举几个例子。 如果想在一个字段中既显示公司名，又显示公司的地址，但这两 个信息一般包含在不同的表列中。 城市、州和邮政编码存储在不同的列中(应该这样)，但邮件标签 打印程序却需要把它们作为一个恰当格式的字段检索出来。 列数据是大小写混合的，但报表程序需要把所有数据按大写表示 出来。 物品订单表存储物品的价格和数量，但不需要存储每个物品的总 价格(用价格乘以数量即可)。为打印发票，需要物品的总价格。 需要根据表数据进行总数、平均数计算或其他计算。在上述每个例子中，存储在表中的数据都不是应用程序所需要的。 我们需要直接从数据库中检索出转换、计算或格式化过的数据;而不是 检索出数据，然后再在客户机应用程序或报告程序中重新格式化。这就是计算字段发挥作用的所在了。与前面各章介绍过的列不同， 计算字段并不实际存在于数据库表中。计算字段是运行时在SELECT语句 内创建的。拼接字段为了说明如何使用计算字段，举一个创建由两列组成的标题的简单例子。vendors表包含供应商名和位置信息。假如要生成一个供应商报表， 需要在供应商的名字中按照name(location)这样的格式列出供应商的位 置。此报表需要单个值，而表中数据存储在两个列vend_name和vend_country中在MySQL的SELECT语句中，可使用Concat()函数来拼接两个列。12345678-- MySQL的不同之处 多数DBMS使用+或||来实现拼接， MySQL则使用Concat()函数来实现。当把SQL语句转换成 MySQL语句时一定要把这个区别铭记在心。SELECT Concat(vend_name,'(',vend_country,')') FROM vendors ORDER BY vend_name;-- 曾提到通过删除数据右侧多余的空格来整理数据，这可以 使用MySQL的RTrim()函数来完成SELECT Concat(RTrim(vend_name),'(',RTrim(vend_country),')') FROM vendors ORDER BY vend_name;-- 使用别名SELECT Concat(RTrim(vend_name),'(',RTrim(vend_country),')') AS vend_title FROM vendors ORDER BY vend_name;-- 执行算数运算SELECT product_id,quantity,item_price,quantity*item_price AS price FROM ordertiems WHERE order_num = 20005; 使用数据处理函数 函数:SQL支持利用函数来处理数据。函数一般是在数据上执行的，它给数据的转换和处理提供了方便。去掉串尾空格的RTrim()就是一个函数例子。大多数SQL实现支持以下类型的函数。 用于处理文本串(如删除或填充值，转换值为大写或小写)的文本函数。 用于在数值数据上进行算术操作(如返回绝对值，进行代数运算)的数值函数。 用于处理日期和时间值并从这些值中提取特定成分(例如，返回两个日期之差，检查日期有效性等)的日期和时间函数。 返回DBMS正使用的特殊信息(如返回用户登录信息，检查版本细节)的系统函数。 文本处理函数1SELECT name,Upper(name) AS name_upcase FROM tablename ,ORDER BY name; 函数 说明 Left() 返回串左边的字符 Length() 返回串的长度 Locate() 找出串的一个子串 Lower() 将串转换为小写 LTrim() 去掉串左边的空格 Right() 返回串右边的字符 RTrim() 去掉串右边的空格 Soundex() 返回串的SOUNDEX值 SubString() 返回子串的字符 Upper() 将串转换为大写 日期和时间处理函数 函数 说明 AddDate() 增加一个日期(天、周等) AddTime() 增加一个时间(时、分等) CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期时间的时间部分 Year() 返回一个日期的年份部分 1234SELECT id,num FROM tablename WHERE Date(data) = \"2017-05-22\";--索出2017年5月下的所有项SELECT id,num FROM tablename WHERE Date(data) BETWEEN '2017-05-01' AND '2017-05-30';SELECT id,num FROM tablename WHERE Year(data)=2017 AND Month(date)=9; 数值处理函数 函数 说明 Abs() 返回一个数的绝对值 Cos() 返回一个角度的余弦 Exp() 返回一个数的指数值 Mod() 返回除操作的余数 Pi() 返回圆周率 Rand() 返回一个随机数 Sin() 返回一个角度的正弦 Sqrt() 返回一个数的平方根 Tan() 返回一个角度的正切 汇总数据聚集数据 我们经常需要汇总数据而不用把它们实际检索出来，为此MySQL提 供了专门的函数。使用这些函数，MySQL查询可用于检索数据，以便分 析和报表生成。这种类型的检索例子有以下几种。 确定表中行数(或者满足某个条件或包含某个特定值的行数)。 获得表中行组的和。 找出表列(或所有行或某些特定的行)的最大值、最小值和平均值。上述例子都需要对表中数据(而不是实际数据本身)汇总。因此， 返回实际表数据是对时间和处理资源的一种浪费(更不用说带宽了)。重 复一遍，实际想要的是汇总信息。为方便这种类型的检索，MySQL给出了5个聚集函数，见表12-1。 这些函数能进行上述罗列的检索。 函数 说明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 聚集不同值1SELECT AVG(DISTINCT price) AS avg_price FROM product WHERE id = 30; 组合聚集函数12345SELECT COUNT(*) AS num_items, MIN(price) AS price_min, MAX(price) AS price_max, AVG(price) AS price_avgFROM products; 分组数据 GROUP BY子句和HAVING子句，分组允许把数据分为多个逻辑组，以 便能对每个组进行聚集计算。 创建分组1SELECT id COUNT(*) AS num_product FROM products GROUP BY id; 具体使用GROUP BY子句前，需要知道一些重要的规定 GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套， 为数据分组提供更细致的控制。 如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上 进行汇总。换句话说，在建立分组时，指定的所有列都一起计算(所以不能从个别的列取回数据)。 GROUP BY子句中列出的每个列都必须是检索列或有效的表达式(但不能是聚集函数)。如果在SELECT中使用表达式，则必须在 GROUP BY子句中指定相同的表达式。不能使用别名。 除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子 句中给出。 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列 中有多行NULL值，它们将分为一组。 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前 过滤分组 除了能用GROUP BY分组数据外，MySQL还允许过滤分组，规定包括 哪些分组，排除哪些分组。例如，可能想要列出至少有两个订单的所有 顾客。为得出这种数据，必须基于完整的分组而不是个别的行进行过滤。在这个例 子中WHERE不能完成任务，因为WHERE过滤指定的是行而不是分组。事实 上，WHERE没有分组的概念。那么，不使用WHERE使用什么呢?MySQL为此目的提供了另外的子 句，那就是HAVING子句。HAVING非常类似于WHERE。事实上，目前为止所 学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是 WHERE过滤行，而HAVING过滤分组。HAVING支持所有WHERE操作符 ，我们学习 了WHERE子句的条件(包括通配符条件和带多个操作符的子 句)。所学过的有关WHERE的所有这些技术和选项都适用于 HAVING。它们的句法是相同的，只是关键字有差别。1SELECT id,COUNT(*) AS orders FROM oders GROUP BY id HAVING COUNT(*) &gt;= 2; HAVING和WHERE的差别 这里有另一种理解方法，WHERE在数据 分组前进行过滤，HAVING在数据分组后进行过滤。这是一个重 要的区别，WHERE排除的行不包括在分组中。这可能会改变计 算值，从而影响HAVING子句中基于这些值过滤掉的分组。同时使用WHERE和HAVING子句例子：12SELECT id ,COUNT(*) AS num_prods FROM products WHERE price &gt;= 10GROUP BY id HAVING COUNT(*)&gt; 2; 分组和排序 虽然GROUP BY和ORDER BY经常完成相同的工作，但它们是非常不同的| ORDER BY | GROUP BY || :————- | :————- || 排序产生的输出任意列都可以使用(甚至非选择的列也可以使用) | 分组行。但输出可能不是分组的顺序只可能使用选择列或表达式列，而且必须使用每个选择列表达式 ||不一定需要|如果与聚集函数一起使用列(或表达式)，则必须使用|12SELECT order_num ,,SUM(quantity* item_price) as ordertotal FROM orderitems GROUP BY order_numHAVING SUM(quantity* item_price)&gt;= 50 ORDER BY ordertotal; 使用子查询 SQL还允许创建子查询(subquery)，即嵌套在其他查询中的查询1234567SELECT cunst_name,cust_contact FROM customers WHERE cust_id IN ( SELECT cust_id FROM orders WHERE order_num IN ( SELECT order_num FROM orderitems WHERE prod_id ='TNT2'));-- 子查询当嵌套太多的时候，性能就会有问题，联结表会解决这个问题 联结表 SQL最强大的功能之一就是能在数据检索查询的执行中联结(join) 表。联结是利用SQL的SELECT能执行的最重要的操作，很好地理解联结 及其语法是学习SQL的一个极为重要的组成部分。维护引用完整性 重要的是，要理解联结不是物理实体。换句 话说，它在实际的数据库表中不存在。联结由MySQL根据需 要建立，它存在于查询的执行当中。在使用关系表时，仅在关系列中插入合法的数据非常重要。回到这里的例子，如果在products表中插入拥有非法供应商ID (即没有在vendors表中出现)的供应商生产的产品，则这些产品是不可访问的，因为它们没有关联到某个供应商。为防止这种情况发生，可指示MySQL只允许在products表的 供应商ID列中出现合法值(即出现在vendors表中的供应商)。 这就是维护引用完整性，它是通过在表的定义中指定主键和外 键来实现的。 创建联结1234SELECT vend_name,prod_name,prod_priceFROM vendors,productsWHERE vendors.vend_id = products.vend_idORDER BY vend_name,prod_name; 内部联结123SELECT vend_name,prod_name,prod_priceFROM vendors INNER JOIN productsON vendors.vend_id = products.vend_id; 联结多个表 SQL对一条SELECT语句中可以联结的表的数目没有限制。创建联结的基本规则也相同。首先列出所有表，然后定义表之间的关系1234SELECT prod_name,vend_name,prod_price,quantityFROM orderitems,products,vendorsWHERE products.vend_id = vendors.vend_id AND orderitems.prod_id = products.prod_id AND order_num = 2005; 创建高级联结基础语法01创建一个表格1234567CREATE TABLE teacher(id TINYINT UNSIGNED NOT NULL,name CHAR(16) NOT NULL,tele NUMERIC(8),sex ENUM(\"F\",\"M\") DEFAULT \"M\") 由上面这个例子可以知道，创建列类型的语法是: col_name col_type [col_attributes][general_attributes] col_name 列的名字 col_type 列类型，控制存储在列中的数据类型 col_attributes 专用属性，只能应用于制定列，例如，我们还不知道的 BINARY。 如果你使用专用属性，必须在列的类型之后，列的通用属性之前。 general_attributes 通用属性，可以应用在出少数列的任意列，例如上面提到了 NULL、 NOT NULL、和 DEFAULT。 MySQL 的数字列类型 ####","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://hillychen.github.io/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://hillychen.github.io/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"http://hillychen.github.io/categories/Mysql/"}]},{"title":"java学习","slug":"Java","date":"2017-03-12T10:00:35.000Z","updated":"2017-03-12T14:10:59.000Z","comments":true,"path":"2017/03/12/Java/","link":"","permalink":"http://hillychen.github.io/2017/03/12/Java/","excerpt":"","text":"","categories":[{"name":"java","slug":"java","permalink":"http://hillychen.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hillychen.github.io/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://hillychen.github.io/categories/java/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-03-12T06:13:43.000Z","updated":"2017-03-12T06:13:43.000Z","comments":true,"path":"2017/03/12/hello-world/","link":"","permalink":"http://hillychen.github.io/2017/03/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}